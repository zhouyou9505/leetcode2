动态规划
01背包：每种物品只有一个
完全背包：每种物品有无穷个
分组背包：每i组有Ci个物品
多重背包：每种物品有Ci个
------------------------------------------------------------------------------------------------------------------------
01背包
常人思维：
-- 如果他放了物品2.万一物品5才是最合适的咋办？（相同重量5的价值大些）
-- 那其实就是前4块方案的价值 vs 放第5块的方案的最优解(放4块，j-w[5])

既要约束它的物品，又要约束他的容量，所以用二位数组
确定状态：c[i][j]表示前i种物品放入容量为j的背包获得最大价值
划分阶段：第i阶段处理第i种物品，第i-1阶段处理第i-1种物品。当处理第i种物品时，前i-1种物品已处理完毕，只需考虑第i-1阶段向第i阶段的转移
for(int i=1;i<=n;i++){
    for(int j=1;j<=n;j++){
        //如果物品i的体积比j还大，那么就直接丢弃
        if(j<w[i]){
            dp[i][j] = dp[i-1][j];
        }else{
            dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+values[i]);
        }
    }
}
时间复杂度O(n*w)  空间复杂度：O(n*w)

用二位数组来表示
423274718-1-208[00_30_31][20220311-231154].png
怎么找到最优解时哪几个物品
![](423274718-1-208[00_34_37][20220311-231042].png)

空间优化：
倒推：01背包节省空间
为什么可以压缩空间：
因为dp[i][j]的值，只和dp[i-1][j]或者dp[i-1][j-w[i]]有关，也就是上一行。所以我在i++的时候，不停的把dp[i]给更新就行了
for(int i=1;i<=n;i++){
    for(int j=W;j>=w[i];j--){
        dp[j] = max(dp[j],dp[j-w[i]]+v[i]);
    }
}
物 1 2 3 4   5
w 4 1 5  1   3
v 2 1 6 100  3

正推：完全背包
for(int i=1;i<=n;i++){
    //为什么从w[i]开始，因为容量不大于当前物品的话，dp[j]=就等于dp[i-1][j]其实就是旧dp[j]
    //正推：case:第4行，等到dp[7]的时候，让旧dp[7]，dp[7-w[4]]+v[1] (dp[1]其实算过了物品4，dp[1]肯定是100)
    //等到dp[8]的时候  旧dp[8] vs dp[8-w[5]]+v[4] (这个其实包括了物品4)，但是肯定是后面带有物品4的最大，所以此时就有2个物品4
    //等到dp[9]的时候  旧dp[9] vs  dp[9-w[5]]+v[4] (这个其实包括2个物品4)，但是肯定是物品4最大，所以此时就有3个物品4
    for(int j=w[i];j<=W;j++){
        dp[j] = max(dp[j],dp[j-w[i]+v[i]);
    }
}
------------------------------------------------------------------------------------------------------------------------
线性dp

最长重复子数组：https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/
最长公共子序列：https://leetcode-cn.com/problems/longest-common-subsequence/solution/


------------------------------------------------------------------------------------------------------------------------